# 이진수

## 문제

양의 정수 n이 주어진다.

이 수를 이진수로 바꿨을 때, **1인 비트의 위치를 모두 출력**하는 프로그램을 작성하시오.

이때, **가장 오른쪽 비트의 위치를 0번**으로 하며, 그 다음 비트를 1번, 그 다음 비트를 2번으로 한다.

## 입력

- 첫째 줄에 테스트 케이스의 개수 T가 주어진다.

- 그 다음 줄부터 T개의 줄에 걸쳐 각각 하나의 정수 n이 주어진다.

    - 1 <= T <= 10

    - 0 <= n = 10<sup>6</sup>

## 출력

- 각 테스트 케이스마다, 정수 n을 이진수로 나타냈을 때 1인 비트의 **위치**를 **오름차순으로 공백으로 구분하여 한 줄에 출력**한다.

## 입력 예시 1

```
2
13
9
```

## 출력 예시 1

```
0 2 3
0 3
```

## 예시 설명

- 13의 이진수는 **1101<sub>2</sub>** 이다.

    -> 오른쪽부터 세면 1인 비트의 위치는 **0, 2, 3**이다.

- 9의 이진수는 **1001<sub>2</sub>** 이다.

    -> 오른쪽부터 세면 1인 비트의 위치는 **0, 3**이다.

## 풀이 아이디어

- 정수를 2진수로 바꾸면 1과 0으로 이루어진 비트열이 된다.

- 비트를 하나씩 검사하면서 1인 자리의 인덱스를 저장하면 된다.

1. 각 테스트 케이스마다 정수 `n`을 입력받는다.

2. 비트의 위치를 나타내는 변수 `pos`를 0으로 시작한다.

3. `n`을 오른쪽으로 한 비트씩 이동시키며,

    - 만약 `n & 1 == 1`이면 현재 비트가 1 -> `pos` 저장

    - 이후 `n >>= 1` , `pos += 1`

4. 저장된 위치들을 공백으로 구분해 출력한다.

## 정답 코드 (Python)

```
import sys

input = sys.stdin.readline

T = int(input()) # 테스트 케이스

for _ in range(T):
    n = int(input())
    pos = 0 # 비트의 위치
    result = []

    while n > 0:
        if n & 1:          # 현재 비트가 1이라면
            result.append(str(pos))
        n >>= 1             # 다음 비트로 이동
        pos += 1

    print(' '.join(result))
```

## 요약

- `& 1`로 1비트를 판별

- `>> 1`로 다음 비트로 이동

- 출력은 공백으로 구분

- 비트는 오른쪽에서부터 0번 인덱스로 센다.