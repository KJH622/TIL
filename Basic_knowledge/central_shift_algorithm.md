# 중앙 이동 알고리즘

![중앙 이동 알고리즘](/Basic_knowledge/img/중앙%20이동%20알고리즘_1.png)

## 문제 요약

- 정사각형 종이의 각 꼭짓점에 점 4개가 찍혀있다. (초기 단계 `n = 0`)

- 각 단계를 한 번 진행할 때마다, 각 작은 정사각형의 중앙에도 점을 하나씩 추가한다.

- 이 과정을 `n`번 반복했을 때, **격자에 찍힌 점의 총 개수**를 구하는 문제이다.

## 규칙 관찰

- 한 변을 따라 있는 점의 개수를 `S(n)`이라고 하자.

    - `n = 0` : 시작 격자 -> 한 변의 점 개수 `S(0) = 2` -> 총 점 개수 `2 * 2 = 4`

    - `n = 1` : 각 작은 정사각형 중앙에 점 추가 -> 한 변 점 개수 `S(1) = 3` -> 총 점 개수 `3 * 3 = 9`

    - `n = 2` : 다시 중앙 추가 -> 한 변 점 개수 `S(2) = 5` -> 총 점 개수 `5 * 5 = 25`

    - `n = 3` : 다시 중앙 추가 -> 한 변 점 개수 `S(3) = 9` -> 총 점 개수 `9 * 9 = 81`

- 여기서 보이는 패턴:

```
S(0) = 2
S(1) = 3
S(2) = 5
S(3) = 9
...
```

- 즉, **한 변의 점 개수 S(n) = 2<sup>n</sup> + 1**

- 그러므로 **총 점 개수 = (2<sup>n</sup> + 1) <sup>2</sup>**

### 왜 S(n) = 2<sup>n</sup> + 1 일까? (짧은 증명 스케치)

- 각 단계에서 기존 점들 사이에 **중간 점**이 생겨서, 한 변의 점 사이 간격(칸 수)이 매번 2배가 된다.

- 간격이 **2<sup>n</sup>** 개가 되므로 점은 간격보다 항상 1개 더 많다. -> **2<sup>n</sup> + 1**

## 예시 테이블

![중앙 이동 알고리즘](/Basic_knowledge/img/중앙%20이동%20알고리즘_2.png)

## 구현 방법

- 직접 공식을 쓰는 것: `answer = (2**n + 1)**2`

- 비트 연산을 사용하는 것:  `answer = ((1 << n) + 1)**2`

    - `2**n` 대신 `1 << n` 사용

### 파이썬 정답 코드 (짧고 빠름)

```
n = int(input().split())
print((2**n + 1)**2)

# 또는
# print(((1 << n) + 1)**2)
```

## 시간/공간 복잡도

- 계산은 상수 시간: **O(1)**

- 추가 메모리 거의 없음: **O(1)**

## 자주 하는 실수

- `n = 0`일 때 결과를 9로 착각하는 경우가 있는데, 정답은 4다. (초기는 2 * 2 격자)

- 정수 오버플로우는 파이썬에서 걱정 X. 다른 언어라면 `long` / `longlong` 사용

## 결론

공식만 기억하자

**정답 = (2<sup>n</sup> + 1)<sup>2</sup>**